学习笔记

# 关于递归，很关键的一点是找出最近重复子问题（自相似性）
最近重复性：就是把大问题化成最近的小问题

# 那么问题来了：如何判断一个问题是否具备重复性
答：如果一个问题不具备的重复性，那么它的复杂度是客观存在的，即对于该问题的解决方案是：将所有的可能一一列举出来才行

还有一种递归方式，找最优重复性，即我们常说的动态规划
类似于统计学，当我们知道n=1，2的情况，我们通过顺序推导出为n时的最优解

# 递归最重要的思想：数学归纳法
1.判断n=1，n=2时，条件成立
2.当n-1时条件成立，可以推导出为n时，条件也成立

# 有关树的前序遍历和中序遍历
前序：[根,[左子树],[右子树]]
中序：[[左子树],根,[右子树]]：先遍历左子树，之后出栈，然后遍历右子树
后序：[[左子树],[右子树],根]  ==> 逆序【类似前序】：[根,[右子树],[左子树]]
1.同一棵树的前序和中序遍历，其左右子树的长度是对应相等的
2.前序寻“根”，找到根，则中序可寻“左右子树”的界限，

# 有关排列组合问题
1.都是递归问题
2.对于组合问题，对于迭代对象，中的每个元素，要么选，要么不选；注意剪枝，一些没有必要的递归，可以不用继续
3.对于排列问题
a.思路1：若从数学定义入手，第一次有n种选法（数组遍历），第二次只能从剩下的n-1中选，...，第n次就只有一种选法了
b.每次选一个，将已选择的放左边，未选择的放右边，可以有效降低空间复杂度
c.思路2：求整个数组的全排列，等效于 求数组中的每个元素放在首位之后，剩余数组的全排列之和
d.思路3：求整个数组的全排列，等效于 求每次数组中的第一个数放在剩余数组的任意位置所组成的全排列
e.思路4：对于有重复元素的全排列，求不重复排列的结果，只要明确去重规则，即可在原基础上解决问题
