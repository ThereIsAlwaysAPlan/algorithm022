学习笔记

关于DFS和BFS，做如下总结：
1.两者的实现 
a.两者都可以用递归实现，相较DFS，BFS不同的一点是在递归的时候需要多记忆level，即层数，因为递归的实现其实用的就是DFS的思想，是一层层深入的，如果没有level，程序就不知道当前递归的数据是哪层的数据，无法将本层数据归纳到一起
b.两者的非递归实现方式
DFS:盗梦空间，归去来兮，和“先进后出"的思想类似，适合用"栈"模拟解决，事实上，递归的实现就是系统自动帮你创建了栈（递归栈，所以递归产生的空间复杂度亦是栈深度）
BFS：先推入本层数据，然后本层数据出去，让下一层数据进来，"先进先出"，适合用“队列”解决问题，也可以考虑用“双指针”法，关键的关键是写入本层数据到数据结构中，之后在取出本层数据的同时，记忆下层数据，方便循环
***：记忆两者模板

分治：将一个具体的问题拆分成N个互斥完全的子问题，再合计所有子问题的解，得出最终的答案
回溯：不放过任何一个可能的答案（暴力，枚举），在无尽的尝试之后，或者找到最终的她（可能的答案），或者失去一切，绝望以归（无解）
***:记忆两者模板

贪心算法：其核心是每次都用局部的最优，最终达到全部的最优
前提：证明使用了贪心之后，可以达到全局的最优，比如coin change问题，如果硬币种类是10，5，1这种具有倍数关系的数据，那自然可以实现由最大的尽量多的硬币种类交换到一定数值的前，并且次数最少
特点：不能回退，每次都计算得出局部最优解（最优子结构）
和动态规划以及回溯的联系和区别
类型    可回退  有最优子结构
贪心    否      有
动规    是      有
回溯    是      无（暴力所有）

对于贪心，有一点体会，有时候对于一个问题，并不能确定它能否由局部最优达到全部最优，那么可以逆向思思维，你先假设它可以达到全局最优，然后逆推它，判断其前一步是否可以满足最优解，依次递推，直到回到起点or回不到，比如：跳跃游戏问题

二分：
前提：1.目标函数的单调性（部分单调也阔以啊）2.对于问题存在上下界 3.可以用index访问
重点：模板记记牢靠
while left <= right:
    mid = left + (right-left)//2
    if mid == target:
        return result
    elif mid > target:
        right = mid - 1
    else:
        left = mid + 1

对于二分的体会，当你发现一个问题满足使用二分算法的条件时，你欣喜若狂，结果发现它只是局部满足，它同时存在多个单调性，不要慌张，分析就是了，分析时一个好的方法便是，二分，每次都砍一半（就问你怕不怕），要么在左边，（重点来了）剩下的在右边（剩下的，划重点，要考的），有时候一个二分的问题你并不能简单的分析出走左边还是走右边的条件，因为很复杂，要满足多个条件才能走一边，那么，分析的时候，只考虑最简单的一边就得了，因为“剩下的”就是另一边的东西，至于条件？else还不够吗。  比如：搜索旋转排序数组

牛顿迭代法，由斜率多次逼近零点，等到误差足够小的时候，就可以认为找到我们想要的了，伟大的公式。r = (r + x/r)//2  注意推导过程，从斜率公式开始，运用一阶求导：x^2 + C => 2x



